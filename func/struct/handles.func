;;
;;  function handlers
;;

() handle::return_transaction(slice sender_addr) impure inline_ref {
    builder return_msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(sender_addr)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0, 32)
        .store_slice(msg::return_msg());
    send_raw_message(return_msg.end_cell(), 64);
}

{-
    SHOULD
    [+] check init auction or not
    [+] check op
    [+] change nft owner
    [+] change auction status
-}
() handle::try_init_auction(slice sender_addr, slice in_msg_body) impure inline_ref {
    throw_if(exit::auction_init(), nft_owner.slice_bits() > 2); ;; throw if auction already init
    throw_unless(exit::no_transfer(), in_msg_body~load_uint(32) == op::ownership_assigned()); ;; throw if it`s not ownership assigned
    in_msg_body~skip_bits(64); ;; query id
    nft_owner = in_msg_body~load_msg_addr();
    end? = 0;
    pack_data();
}


{-
    SHOULD
    [+] return prev bid 
    [+] return nft to owner
    [+] reserve 0,001 ton 
-}
() handle::try_cancel(slice in_msg_body) impure inline_ref {
    throw_unless(exit::not_message(), in_msg_body~load_uint(32) == 0); ;;throw if it`s not message
    throw_unless(exit::not_cancel(), equal_slices?(in_msg_body, msg::cancel_msg())); ;; throw if msg not "Cancel"


    builder bid_return = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(last_member)
        .store_coins(last_bid)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0, 32)
        .store_slice(msg::bid_return());
    
    send_raw_message(bid_return.end_cell(), 2); ;; ignore errors

    builder nft_return_body = begin_cell()
        .store_uint(op::transfer(), 32)
        .store_uint(cur_lt(), 64) ;; query id
        .store_slice(nft_owner) ;; new owner
        .store_slice(nft_owner) ;; response_destination
        .store_uint(0, 1) ;; custom payload
        .store_coins(0) ;; forward amount
        .store_uint(0, 1); ;; forward payload
    
    builder nft_return_msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(nft_addr)
        .store_coins(0)
        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(nft_return_body.end_cell());
    raw_reserve(1000000, 0); ;; reserve some bebras  üêà
    send_raw_message(nft_return_msg.end_cell(), 128);
    end? = 1;
    pack_data();
}

{-
    SHOULD
    [+] transfer nft
    [+] send marketplace fee
    [+] send royalty fee
    [+] reserve 0,001 ton 
    [+] send profit to previous nft owner
    [+] change auction status
-}
() handle::end_auction() impure inline_ref {
    builder nft_transfer_body = begin_cell()
        .store_uint(op::transfer(), 32)
        .store_uint(cur_lt(), 64) ;; query id
        .store_slice(last_member) ;; new owner
        .store_slice(last_member) ;; response_destination
        .store_uint(0, 1) ;; custom payload
        .store_coins(0) ;; forward amount
        .store_uint(0, 1); ;; forward payload
     builder nft_transfer = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(nft_addr)
        .store_coins(100000000) ;; 0,1 ton
        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(nft_transfer_body.end_cell());
    send_raw_message(nft_transfer.end_cell(), 2);


    int mp_fee = math::get_percent(last_bid, mp_fee_percent, mp_fee_factor);
    
    builder mp_transfer = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(mp_fee_addr)
        .store_coins(mp_fee)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0, 32)
        .store_slice(msg::mp_msg());
    
    send_raw_message(mp_transfer.end_cell(), 3);

    int royalty_fee = math::get_percent(last_bid, royalty_fee_percent, royalty_fee_factor);

    builder royalty_transfer = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(royalty_fee_addr)
        .store_coins(royalty_fee)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0, 32)
        .store_slice(msg::royalty_msg());
    
    send_raw_message(royalty_transfer.end_cell(), 3);

    raw_reserve(1000000, 0); ;; reserve some bebras  üêà

    builder prev_owner_msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(nft_owner)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0, 32)
        .store_slice(msg::profit_msg());
    
    send_raw_message(prev_owner_msg.end_cell(), 128);
    end? = 1;
    pack_data();
}


{-
    SHOULD 
    [+] check time  
    [+] check bid step amount
    [+] check init auction or not 
    [+] return prev bid
    [+] change bid info
    [+] check max bid
-}
() handle::new_bid(slice sender_addr, int msg_value) impure inline_ref {
    throw_if(exit::auction_end(), end? == 1);

    if (end_time < now()) {
        handle::return_transaction(sender_addr);
        handle::end_auction();
        return ();
    }

    if (msg_value >= max_bid) {
        builder return_prev_bid = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(last_member)
            .store_coins(last_bid)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(0, 32)
            .store_slice(msg::bid_return());
        send_raw_message(return_prev_bid.end_cell(), 2);
        last_member = sender_addr;
        last_bid = msg_value;
        handle::end_auction();
        return ();
    }

    if (msg_value < (last_bid + min_step)) {
        handle::return_transaction(sender_addr);
        return ();
    }
    
    builder return_prev_bid = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(last_member)
            .store_coins(last_bid)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(0, 32)
            .store_slice(msg::bid_return());
    send_raw_message(return_prev_bid.end_cell(), 2);

    last_member = sender_addr;
    last_bid = msg_value;
    pack_data();
}
